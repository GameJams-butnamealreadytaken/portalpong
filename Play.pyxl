Play
════════════════════════════════════════════════════════════════════════

let alienPos = xy(½ SCREEN_SIZE.x, 132)
let flip = xy(1, 1)

let p1Pos = xy(15, SCREEN_SIZE.y / 2)
let p1Score = 0
let p2Pos = xy(SCREEN_SIZE.x - 15, SCREEN_SIZE.y / 2)
let p2Score = 0

let maxRacketY = xy(racket_size, SCREEN_SIZE.y - racket_size)

todo("Ball struct ?")
let ballPos = xy(SCREEN_SIZE.x / 2 + 15,SCREEN_SIZE.y / 2)
let ballDir = xy(1, 0)
let ballSpeed = 1

def InitBall():
    ballPos = xy(SCREEN_SIZE.x / 2 + 15,SCREEN_SIZE.y / 2)
    ballDir = xy(1, 1) 
    todo("dir to loser of last point")
    ballSpeed = 1
    
enter
────────────────────────────────────────────────────────────────────────
// Background
set_background(rgb(0))
p1Score = 0
p2Score = 0
InitBall()

frame
────────────────────────────────────────────────────────────────────────

//
// Middle line
draw_line(xy(192, 0), xy(192, SCREEN_SIZE.y), rgb(100, 100, 100), 0, 3)

//
// Portal max limits
draw_line(xy(60, 0), xy(60, SCREEN_SIZE.y), rgba(100, 0, 0, 0.2))
draw_line(xy(324, 0), xy(324, SCREEN_SIZE.y), rgba(0, 0, 100, 0.2))

//
// Rackets
if gamepad_array[0].y:
    p1Pos.y = clamp(p1Pos.y + (gamepad_array[0].y * racket_speed), maxRacketY.x, maxRacketY.y)
if gamepad_array[1].y:
    p2Pos.y = clamp(p2Pos.y + (gamepad_array[1].y * racket_speed), maxRacketY.x, maxRacketY.y)

draw_line(xy(p1Pos.x, p1Pos.y - racket_size), xy(p1Pos.x, p1Pos.y + racket_size), rgb(100, 100, 100), 0, racket_width)
draw_line(xy(p2Pos.x, p2Pos.y - racket_size), xy(p2Pos.x, p2Pos.y + racket_size), rgb(100, 100, 100), 0, racket_width)

//
// Ball
let newBallX = ballPos.x + ballDir.x * ballSpeed
let newBallY = ballPos.y + ballDir.y * ballSpeed

// Ball oob
if newBallX < 0:
    p2Score++
    InitBall()
else if newBallX > SCREEN_SIZE.x:
    p1Score++
    InitBall()
else:
    // Walls collisions
    if newBallY < ball_size:
        newBallY = ball_size
        ballDir.y *= -1
    else if newBallY > SCREEN_SIZE.y - ball_size:
        newBallY = SCREEN_SIZE.y - ball_size
        ballDir.y *= -1
    else:
        // Rackets collisions
        if ballPos.x > p1Pos.x && newBallX < p1Pos.x + racket_width:
            if newBallY + ball_size ≥ p1Pos.y - racket_size && newBallY - ball_size ≤p1Pos.y + racket_size:
                newBallX = p1Pos.x + racket_width
                ballDir.x *= -1
                if abs(newBallY - p1Pos.y) > racket_size:
                    ballDir.y += 0.5 // TODO adjust value + max
        else if ballPos.x < p2Pos.x && newBallX > p2Pos.x - racket_width:
            if newBallY + ball_size ≥ p2Pos.y - racket_size && newBallY - ball_size ≤ p2Pos.y + racket_size:
                newBallX = p2Pos.x - racket_width
                ballDir.x *= -1
                if abs(newBallY - p1Pos.y) < racket_size:
                    ballDir.y += 0.5 // TODO adjust value + max
                    
    ballPos.x = newBallX
    ballPos.y = newBallY

draw_rect(ballPos, xy(ball_size, ball_size), rgb(100,100,100))

//
// Draw scores
draw_text(font, format_number(p1Score, ""), xy(SCREEN_SIZE.x/2 - 50, 50), #FFF)
draw_text(font, format_number(p2Score, ""), xy(SCREEN_SIZE.x/2 + 50, 50), #FFF)

// Alien
let sprite = astronaut.crawl[0]
if joy.x:
   flip.x = joy.x
   sprite = astronaut.crawl[floor(mode_frames / 10) mod 2]
   alienPos.x = loop(alienPos.x + joy.x, SCREEN_SIZE.x)

draw_sprite(sprite, alienPos, 0, flip)


